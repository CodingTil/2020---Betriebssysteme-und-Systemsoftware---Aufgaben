\documentclass[11pt]{article}

%Packages
\usepackage{amsfonts}	      %Mathematische Zeichen und Fonts
\usepackage{mathtools}        %Extra Mathematische Symbole
\usepackage{extarrows}	      %Extra Pfeile
\usepackage{listings}         %Codeansicht
\usepackage{scrlayer-scrpage} %Seitenkopf
\usepackage{tikz}             %tikz
\usepackage{enumitem}		  %Enumerate
\usepackage{listings}		  %Code snippets
\usepackage{amsmath}

\usetikzlibrary{arrows, automata, positioning}
\pagestyle{scrheadings}

\begin{document}

%Header
\ihead{\textbf{Betriebssysteme und Systemsoftware \\ Übungsblatt 03} \\Tutorium 1}
\ohead{Andrés Montoya, 405409 \\ Til Mohr, 405959\\ Marc Ludevid Wulf, 405401}

%Seiteninhalt
\paragraph{Aufgabe 3.1}
\begin{enumerate}[label=\alph*)]
\item Siehe prozesse.c.

\item fprintf nutzt im Gegensatz zu write einen Buffer. Dieser muss mittels fflush "losgeschickt" werden. Dies ist bei write nicht notwendig, da der übergebene String direkt dem Kernel übergeben wird um diesen zu printen. Bei mehreren Ausgaben ist fprintf besser in dem Sinn, dass es die String zusammenfasst und diese mit einem fflush alle zussammen ausgedruckt werden können. Da bei write jedes mal, das etwas gedruckt wird ein syscall ausgeführt wird ist es in diesem Fall langsamer. Soll eine Ausgabe so schnell wie möglich geprintet werden sollte man write nutzen. In jedem anderen Fall sollte fprintf und fflush effizienter sein.

\item Zombie-Prozesse sind Prozesse die zwar geendet haben, aber der zugehörige Parent-Prozess den Exit-Status noch nicht gelesen hat. Das heisst, dass noch nicht wait() aufgerufen wurde. Sobald der exit-Status gelesen wurde kann der Prozess dann von der Prozess-Tabelle entfernt werden.

\item Ein einfaches Beispiel könnte das Senden von Signalen zur Kommunikation mit dem Parent-Prozess sein, welches die PID benötigt.

\item Siehe letter\_count.c.
\end{enumerate}

\paragraph{Aufgabe 3.2}
\begin{enumerate}[label=\alph*)]
\item In den Blättern stehen alle Ausgaben, die von dem jeweiligen Prozess erzeugt wurden. In den Knoten stehen die Zeilennummern, an denen die $fork$-Anweisung ausgeführt wurde.
\begin{center}
\rotatebox{270}{
\begin{tikzpicture}[
  level 1/.style={sibling distance=25em},
  level 2/.style={sibling distance=18em},
  level 3/.style={sibling distance=10em},
  level 4/.style={sibling distance=4em},
  every node/.style = {shape=rectangle, rounded corners,
    draw, align=center,
    top color=white, bottom color=blue!20}]]
  \node {6}
    child { node {8} 
		child { node {$B,S$} }
		child { node {$u,S$} }    
    }
    child { node {16}
    	child { node {17}
    		child { node {19}
    			child { node {$Zwan$} }
    			child { node {$20,Zig$} }
    		}
    		child { node {19}
    			child { node {$Zwan$} }
    			child { node {$20,Zig$} }
    		}
    	}
    	child { node {17}
    		child { node {19}
    			child { node {$Zwan$} }
    			child { node {$20,Zig$} }
    		}
    		child { node {19}
    			child { node {$Zwan$} }
    			child { node {$20,Zig$} }
    		}
    	}
    };
\end{tikzpicture}
}
\end{center}

\item $u$ wird vor $B$ ausgegeben, da der Prozess, der $B$ ausgibt, ein Kindprozess von dem Prozess ist, der $u$ ausgibt. In Zeile 8 wird dieser Prozess erstellt. Der Elternprozess gibt aber fast sofort später $u$ aus, während der Kindprozess noch gestartet wird.

\item \verb|wait(NULL)| warted auf die Terminierung $eines$ Kindprozesses und gibt die PID des jeweiligen Kindprozesses zurück. Wenn \verb|wait(NULL)| $0$ zurückgibt, bedeutet dies, dass bereits alle Kindprozesse terminiert sind. Fügt man also zum Ende von \verb|main| die Zeile \verb|while(wait(NULL) > 0);| hinzu, so terminiert erst der Root-Prozess, wenn alle seiner Kinder terminiert sind. Dies gilt analog auch für alle Kindprozesse, die erst terminieren, wenn deren Kinder terminiert sind.
\end{enumerate}

\paragraph{Aufgabe 3.3}
\begin{enumerate}[label=\alph*)]
\item
\begin{tabular}{ |p{3cm}||p{5cm}|p{5cm}| }
\hline
& Vorteile & Nachteile \\
\hline
\hline
Pipes &
\begin{itemize}
\item Vereinfachte Synchronisation zwischen Prozessen
\end{itemize} & \begin{itemize}
\item Einseitiger Informationsfluss
\item Langsame Kommunikation
\item Prozesse können freezen
\end{itemize}\\
\hline
Shared Memory & \begin{itemize}
\item Beschleunigung der Kommunikation
\item Beidseitige Informationsfluss möglich
\item Prozesse unabhängig von einander $\rightarrow$ freezen nicht
\end{itemize} & \begin{itemize}
\item Erfordert Synchronisation zwischen Prozessen
\end{itemize}\\
\hline
\end{tabular}

\item Named Pipes haben die gleichen Vorteile und Nachteile wie normale Pipes, das heisst, dass eine Synchronisation zwischen den Prozessen nicht notwendig ist, andererseits ist die Kommmunikation nur einseitig und es kann zum Freezen eines Prozesses kommen. Named Pipes haben einen Eintrag im Dateisystem, also eine Kennung und sind durch Zugriffrechte identifizierbar.

Während Pipes Bytestreams benutzen, verwenden Messages eine vordefinierte Länge und können getyped sein. Message Passing ist ausserdem geeigent für Kommunikation zwischen mehreren Prozessen.

Shared Memory nutzt gemeinsame Speicherbereiche die geschützt werden müssen. Der Zugriff muss ausserdem synchronisiert werden. Dafür sind sie jedoch effizienter und beschleunigen somit die Kommmunikation.

\item Ein Prozess bezeichnet ein Programm im Stadium der Ausführung. Dazu wird jedem Prozess ein Process Control Block (PCB) zugewiesen, der aktuelle Werte und Zustände des Prozesses beinhaltet. Hierzu zählen beispielsweise alle Register, die Daten auf dem Arbeitsspeicher und vom Prozess geöffnete Dateien. Zudem besitzt jede PCB einen Programmzähler, wodurch erst die simultane Abarbeitung von Prozessen auf einer CPU ermöglicht wird.\\
Ein Thread ist eine Erweiterung des Prozess-Konzepts. Ein Prozess kann mehrere Threads erstellen, was eine Granulierung in der Strukturierung ermöglicht. Da jeder Thread einen eigenen Kontrollfluss besitzt, kann man hierdurch unabhängige Teilaufgaben gleichzeitig bearbeiten. Zudem teilen sich die Threads eines Programmes einige Werte und Zustände, neben der CPU-Zeit. All dies kann zu einer effizienteren Abarbeitung mit Threads als ohne führen.

\item Zu viele Threads sind schlecht, da diese System resources verbrauchen, wie zum Beispiel CPU-time oder Kernel-Funktionsaufrufen, wodurch auch Bugs enstehen können. Zudem fügen sie Komplexität zum Code hinzu, was Verständlichkeit und Robusheit verschlechtert und dadurch das Debuggen erschweren.
\end{enumerate}
\end{document}